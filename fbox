#!/usr/bin/env python

# Version : 1.0.0
# Author  : faizal_zakaria@sigmadesigns.com

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import sys
import subprocess
import yaml

#############################################################################
# global variables
#############################################################################

author = "Faizal Zakaria"
fbox_filename = "fboxfile"
dir = {}
dir['pwd'] = os.getcwd()
fboxfile = os.path.join(dir['pwd'], fbox_filename)

template = ""
fbox_name = ""
archi = ""
revision = ""

####################################################################
# Colors
####################################################################

green = "\033[32m"
red  = "\033[35m"
endc = "\033[0m"

####################################################################
# Functions
####################################################################

def usage(argv):
    print("\n-------------------------------------------------")
    print("Usage :")
    print("%s init    : To initialize" % (argv[0]))
    print("%s up      : To start lxc" % (argv[0]))
    print("%s halt    : To halt lxc" % (argv[0]))
    print("%s destroy : To destroy lxc" % (argv[0]))
    print("%s console : To go to lxc console" % (argv[0]))
    print("-------------------------------------------------\n")

###########################################
# Commands
###########################################

def cmd_init():
    print(sys._getframe().f_code.co_name)
    f = open(fboxfile, 'w')
    f.write("#Auto generated file\n")
    f.write("#This will have all the fbox config\n")
    f.close()

def cmd_up():
    print(sys._getframe().f_code.co_name)

    #############################################
    ###### Check if its already created #########


    #############################################
    ################ Create #####################
    cmd = [ "sudo", "lxc-create", "-t", template, "-n", fbox_name, "--" ]
    cmd.extend(['-a', archi, '-r', revision])

    printc("executing command : %s" % ' '.join(cmd), green)
    printc("Could take a while, please wait ...", green)
    if execute(cmd, True) != 0:
        printc("Failed to execute %s" % cmd, red)

    #############################################
    ################## Run ######################
    
def cmd_halt():
    print(sys._getframe().f_code.co_name)

def cmd_destroy():
    print(sys._getframe().f_code.co_name)

def cmd_console():
    print(sys._getframe().f_code.co_name)

def cmd_status():
    cmd = [ "sudo", "lxc-ls", "|", "grep", "^$%s$" % fbox_name ]
    if execute(cmd) != 0:
        printc("Failed to execute %s" % cmd, red)

###########################################
# Helper
###########################################

def load_config(configfile):
    with open(configfile, 'r') as getConfig:
        return yaml.load(getConfig.read())

def write_config(configfile, data):
    with open(configfile, 'w') as setConfig:
        setConfig.write(yaml.dump(d, indent=4, default_flow_style=False))

def print_config(config):
    print yaml.dump(config, indent=4, default_flow_style=False)

def fboxfile_exist():
    if not os.path.exists(fboxfile):
        return False
    return True

def printc(msg, color):
    print(color + msg + endc)

def exec_cmd(cmd):
    if cmd in globals():
        if cmd != "cmd_init" and not fboxfile_exist():
            printc("You need to run fbox init first", green)
            return 1
        elif cmd == "cmd_init" and fboxfile_exist():
            printc("fboxfile is not empty", green)
            return 1
        globals()[cmd]()
        return 0
    else:
        printc("fbox does not understand your command : %s" % cmd, green)
        return 1

def execute(cmd, verbose=False):
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    if verbose:
        while True:
            out = p.stdout.read(1)
            if out == '' and p.poll() != None:
                break
            if out != '':
                sys.stdout.write(out)
                sys.stdout.flush()
    output = p.communicate()
    return p.returncode

#############################################################################
# main()
#############################################################################

def main(argv=sys.argv):

    print("fbox by %s" % author)

    ###########################################
    # Check usage
    ###########################################

    if argv.__len__() < 2 or argv.__len__() > 2:
        usage(argv)
        return -1

    ###########################################
    # Get command and execute
    ###########################################

    ###########################################
    # Load fboxfile
    ###########################################
    config = load_config(fboxfile)

    print_config(config['container'])

    global template
    global fbox_name
    global archi
    global revision
    template = config['container']['template']
    fbox_name = config['container']['name']
    archi = config['container']['args']['archi']
    revision = config['container']['args']['revision']

    ###########################################
    # Get command and execute
    ###########################################

    cmd = "cmd_%s" % argv[1]
    if exec_cmd(cmd):
        usage(argv)
        return -1


if __name__ == "__main__":
    main()





